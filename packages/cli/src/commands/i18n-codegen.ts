import { Command } from "commander";
import { resolve, join, basename } from "node:path";
import { readdir, readFile, writeFile, watch } from "node:fs/promises";
import { log } from "../utils/logger.js";
import { pathExists } from "../utils/fs.js";
import pc from "picocolors";

export const i18nCodegenCommand = new Command("i18n-codegen")
  .description("Generate TypeScript types from i18n JSON files")
  .option("--watch", "Watch for file changes", false)
  .action(async (flags: { watch: boolean }) => {
    const rootDir = resolve(process.cwd());
    const modulesDir = join(rootDir, "modules");

    if (!(await pathExists(modulesDir))) {
      log.error("No modules/ directory found. Run from a simplix project root.");
      process.exit(1);
    }

    console.log("");
    console.log(pc.bold("simplix i18n-codegen"));
    console.log("");

    const count = await generateAll(modulesDir);

    if (count === 0) {
      log.warn("No i18n locale directories found.");
    } else {
      log.success(`Generated ${count} keys.d.ts file${count !== 1 ? "s" : ""}.`);
    }

    if (flags.watch) {
      console.log("");
      console.log(pc.blue("  Watching for i18n file changes..."));

      const localeDirs = await discoverLocaleDirs(modulesDir);

      for (const localeDir of localeDirs) {
        const ac = new AbortController();
        watchDir(localeDir, ac.signal).catch(() => {
          // watcher closed
        });
      }
    }
  });

async function generateAll(modulesDir: string): Promise<number> {
  const localeDirs = await discoverLocaleDirs(modulesDir);
  let count = 0;

  for (const localeDir of localeDirs) {
    const generated = await generateKeysFile(localeDir);
    if (generated) count++;
  }

  return count;
}

async function discoverLocaleDirs(modulesDir: string): Promise<string[]> {
  const dirs: string[] = [];

  if (!(await pathExists(modulesDir))) return dirs;

  const moduleEntries = await readdir(modulesDir, { withFileTypes: true });

  for (const moduleEntry of moduleEntries) {
    if (!moduleEntry.isDirectory() || moduleEntry.name.startsWith(".")) continue;

    const localesRoot = join(modulesDir, moduleEntry.name, "src", "locales");
    if (!(await pathExists(localesRoot))) continue;

    // Recursively find directories containing .json locale files
    await findLocaleDirsRecursive(localesRoot, dirs);
  }

  return dirs;
}

async function findLocaleDirsRecursive(
  dir: string,
  result: string[],
): Promise<void> {
  const entries = await readdir(dir, { withFileTypes: true });

  const hasJsonFiles = entries.some(
    (e) => e.isFile() && e.name.endsWith(".json"),
  );

  if (hasJsonFiles) {
    result.push(dir);
  }

  for (const entry of entries) {
    if (entry.isDirectory() && !entry.name.startsWith(".")) {
      await findLocaleDirsRecursive(join(dir, entry.name), result);
    }
  }
}

async function generateKeysFile(localeDir: string): Promise<boolean> {
  const entries = await readdir(localeDir, { withFileTypes: true });

  const jsonFiles = entries
    .filter((e) => e.isFile() && e.name.endsWith(".json"))
    .map((e) => e.name);

  if (jsonFiles.length === 0) return false;

  // Prefer en.json as the source of truth, fallback to first JSON file
  const sourceFile = jsonFiles.includes("en.json") ? "en.json" : jsonFiles[0];
  const filePath = join(localeDir, sourceFile);

  const content = await readFile(filePath, "utf-8");
  let json: Record<string, unknown>;
  try {
    json = JSON.parse(content) as Record<string, unknown>;
  } catch {
    log.warn(`Failed to parse ${filePath}`);
    return false;
  }

  const keys = flattenKeys(json);

  if (keys.length === 0) return false;

  const namespace = toTypeName(basename(localeDir));
  const keysType = `${namespace}Keys`;

  const lines = [
    "// Auto-generated by simplix i18n-codegen",
    "// Do not edit manually",
    "",
    `export type ${keysType} =`,
    ...keys.map((key, i) => {
      const prefix = i === 0 ? "  | " : "  | ";
      const suffix = i === keys.length - 1 ? ";" : "";
      return `${prefix}"${key}"${suffix}`;
    }),
    "",
  ];

  const outputPath = join(localeDir, "keys.d.ts");
  await writeFile(outputPath, lines.join("\n"), "utf-8");

  log.step(`${keysType} â†’ ${outputPath}`);

  return true;
}

function flattenKeys(obj: Record<string, unknown>, prefix = ""): string[] {
  const keys: string[] = [];
  for (const [key, value] of Object.entries(obj)) {
    const fullKey = prefix ? `${prefix}.${key}` : key;
    if (value && typeof value === "object" && !Array.isArray(value)) {
      keys.push(...flattenKeys(value as Record<string, unknown>, fullKey));
    } else {
      keys.push(fullKey);
    }
  }
  return keys;
}

function toTypeName(dirName: string): string {
  return dirName
    .split("-")
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join("");
}

async function watchDir(localeDir: string, signal: AbortSignal): Promise<void> {
  const watcher = watch(localeDir, { signal });

  for await (const event of watcher) {
    if (event.filename && event.filename.endsWith(".json")) {
      log.info(`Change detected: ${join(localeDir, event.filename)}`);
      try {
        await generateKeysFile(localeDir);
        log.success("Regenerated keys.d.ts");
      } catch (err) {
        log.error(`Failed to regenerate: ${String(err)}`);
      }
    }
  }
}
